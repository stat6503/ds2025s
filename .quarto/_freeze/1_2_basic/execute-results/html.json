{
  "hash": "7ec521414f9e1947276eb715d93005e4",
  "result": {
    "engine": "jupyter",
    "markdown": "---\njupyter: python3\n---\n\n\n\n\n<h1>2. 기초 문법</h1>\n\n## 2.1. 변수\n+ 변수(variable)\n  + 값을 저장하는 공간\n  + (할당) `변수명` = 값\n\n<br>\n\n+ 변수의 특징\n  + 일시적으로 자료를 저장하는 공간으로, 변수에 저장된 값은 변할 수 있음\n  + 숫자, 문자열 등 모든 자료형을 저장할 수 있고, 다른 변수의 값도 저장할 수 있음\n  + 변수는 사용되기 전에 반드시 할당되어 있어야 함\n\n<br>\n\n+ 변수명 작성 규칙\n  1. 영문자, 숫자, `_`로 구성될 수 있으며, 첫 글자는 반드시 영문자나 `_`로 시작함\n  2. 공백을 포함할 수 없음\n  3. 대문자와 소문자를 구별함\n  4. Python에서 다른 용도로 사용되는 예약어는 사용할 수 없음\n\n<br>\n\n::: {#7ad39f21 .cell execution_count=1}\n``` {.python .cell-code}\n# 변수 생성1 : 숫자\na = 100\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n100\n```\n:::\n:::\n\n\n::: {#183cf003 .cell execution_count=2}\n``` {.python .cell-code}\n# 변수 사용\nprint(a)\na = a + 50\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n100\n150\n```\n:::\n:::\n\n\n::: {#cb363680 .cell execution_count=3}\n``` {.python .cell-code}\n# 변수 생성2 : 문자열\nname = '이순신'\naddr = \"서울시\"\nprint(name, addr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n이순신 서울시\n```\n:::\n:::\n\n\n::: {#2cab7ec3 .cell execution_count=4}\n``` {.python .cell-code}\n# 예약어\nimport keyword\nprint(keyword.kwlist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n```\n:::\n:::\n\n\n<br>\n\n+ \\[Note\\] 주석(comment)\n  + 프로그램 안에서 코드가 아닌 텍스트로 작성되며, 프로그램 실행 시 무시됨\n  + 코드의 기능을 설명하거나 알아야할 사항을 기록할 때 사용함\n  + 한 줄 주석 처리 : `# comment`\n  + 여러 줄 주석 처리 : `''' comment '''`, `\"\"\" comment \"\"\"`\n\n<br>\n\n+ \\[Note\\] 기본 자료형\n\n|자료형|의미|예시|\n|:---:|:------|:------|\n|int|integer, 정수|100|\n|float|float, 부동 소수점|95.7|\n|str|string, 문자열|'Lee'|\n|bool|boolean, 부울|True <br>False|\n\n<br>\n\n::: {#fbc0f665 .cell execution_count=5}\n``` {.python .cell-code}\n# 기본 자료형\nprint(type(100))\nprint(type(95.7))\nprint(type('Lee'))\nprint(type(True))\nprint(type(False))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'int'>\n<class 'float'>\n<class 'str'>\n<class 'bool'>\n<class 'bool'>\n```\n:::\n:::\n\n\n<br>\n\n## 2.2. 연산자\n### 2.2.1. 산술 연산자\n\n|연산자|의미|예시|결과|\n|:---:|:------|:------|------:|\n|+|더하기|10+20|30|\n|-|빼기|10-20|-10|\n|*|곱하기|10*20|200|\n|/|나누기|10/20|0.5|\n|//|나눈 정수 몫|10//20|0|\n|%|나눈 나머지|10%20|10|\n|**|거듭제곱|10**2|100|\n\n<br>\n\n### 2.2.2. 대입 연산자\n+ 변수에 값을 할당(assignment)하는 연산자\n+ 기본적으로 `=`를 사용하며, 산술 연산자와 함께 사용하면 할당을 보다 간결하게 할 수 있음\n\n\n|연산자|의미|예시|\n|:---:|:------------------|:------|\n|=|왼쪽 변수에 오른쪽 값을 할당|x=10|\n|+=|왼쪽 변수에 오른쪽 값을 더하고 결과를 왼쪽 변수에 할당|x+=10|\n|-=|왼쪽 변수에 오른쪽 값을 빼고 결과를 왼쪽 변수에 할당|x-=10|\n|\\*=|왼쪽 변수에 오른쪽 값을 곱하고 결과를 왼쪽 변수에 할당|x\\*=10|\n|/=|왼쪽 변수에 오른쪽 값을 나눈 결과를 왼쪽 변수에 할당|x/=10|\n|//=|왼쪽 변수에 오른쪽 값을 나눈 몫의 결과를 왼쪽 변수에 할당|x//=10|\n|%=|왼쪽 변수에 오른쪽 값을 나눈 나머지의 결과를 왼쪽 변수에 할당|x%=10|\n|**=|왼쪽 변수에 오른쪽 값만큼 거듭제곱을 하고 결과를 왼쪽 변수에 할당|x\\*\\*=2|\n\n<br>\n\n### 2.2.3. 비교 연산자\n+ 두 개 이상의 식 또는 변수의 비교를 위해 사용하는 연산자\n+ 결과는 참(True) 또는 거짓(False)으로 나타남\n+ 단독으로 사용되는 경우보다는 주로 조건문과 반복문에서 사용됨\n\n\n|연산자|의미|예시|결과|\n|:---:|:------------------|:------|:------|\n|==|값이 동일하다|10==20|False|\n|!=|값이 동일하지 않다|10!=20|True|\n|>|왼쪽 값이 오른쪽 값보다 크다|10>20|False|\n|>=|왼쪽 값이 오른쪽 값보다 크거나 동일하다|10>=20|False|\n|<|왼쪽 값이 오른쪽 값보다 작다|10<20|True|\n|<=|왼쪽 값이 오른쪽 값보다 작거나 동일하다|10<=20|True|\n\n<br>\n\n### 2.2.4. 논리 연산자\n+ 참(True)과 거짓(False)의 논리 동작을 다루는 연산자\n+ 여러 조건을 조합할 때 주로 사용됨\n\n|연산자|의미|예시|결과|\n|:---:|:------------------|:------|:---|\n|and|논리 AND 연산, 왼쪽 식과 오른쪽 식 모두 참인 경우에만 True|a=25 <br>print(a>8 and a<60)|True|\n|or|논리 OR 연산, 왼쪽 식과 오른쪽 식 중 하나라도 참인 경우에만 True|a=70 <br>print(a<8 or a>=60)|True|\n|not|논리 NOT 연산, 오른쪽 식이 참이면 False, 거짓이면 True|a=20 <br>print(not a==20)|False|\n\n\n<br>\n\n## 2.3. 표준 입출력\n+ 표준 입력\n  + 사용자로부터 값을 입력받기 위해 `input() 함수`를 사용함\n  + `input()` 함수는 안내문을 출력한 후 사용자의 입력을 기다리며, 입력한 값을 문자열로 저장함\n  + 입력한 값을 숫자로 사용하려면 `int()`, `float()` 함수를 이용하여 형 변환해야 함\n  + `변수 = input(안내문)`\n\n<br>\n\n+ 표준 출력\n  + 값을 출력하기 위해 `print()` 함수를 사용함\n  + 여러 값을 `,`로 구분하여 출력할 수 있음\n  + f-string 포맷팅\n    + 문자열 맨 앞에 f를 붙이고 `{}` 안에 변수명을 직접 작성하여 출력하는 방식\n    + 가독성이 좋고 사용 방법이 간단하여 자주 사용됨\n\n<br>\n\n::: {#953e0663 .cell execution_count=6}\n``` {.python .cell-code}\n# 표준 입출력\n#x = int(input('첫 번째 숫자 입력 : '))\n#y = int(input('두 번째 숫자 입력 : '))\n#print('두 수의 합 : ', x, ' + ', y, ' = ', x+y)\n```\n:::\n\n\n::: {#ecf57e80 .cell execution_count=7}\n``` {.python .cell-code}\n# f-string 포맷팅\n#print(f'두 수의 차 : {x} - {y} = {x-y}')\n```\n:::\n\n\n<br>\n\n## 2.4. 컬렉션 자료형\n### 2.4.1. 컬렉션 자료형\n+ 컬렉션 자료형(collection data type)\n  + 여러 개의 값을 하나의 변수에 저장할 수 있는 자료형\n  + 대표적으로 리스트(list), 튜플(tuple), 딕셔너리(dictionary), 세트(set)가 있음\n\n<br>\n\n### 2.4.2. 리스트\n+ 리스트(list)\n  + 여러 개의 값을 저장할 수 있는 자료구조로, `[]` 안에 값을 `,`로 구분하여 나열함\n  + 숫자형, 문자열, 리스트 등 서로 다른 자료형을 함께 저장할 수 있음\n  + 순서가 있는(ordered) 구조로, 인덱스(index)를 통해 각 요소에 접근할 수 있음\n    + 인덱싱(indexing) : `[index]`를 사용하여 리스트의 특정 위치에 있는 요소에 접근함\n    + 슬라이싱(slicing) : `[start:stop]`를 사용하여 리스트의 일부 요소에 접근함\n  + 한 번 생성한 후에도 값을 추가, 변경, 삭제할 수 있음\n\n<br>\n\n::: {#559043ef .cell execution_count=8}\n``` {.python .cell-code}\n# 리스트 생성1\nx = [10, 20, 30]\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10, 20, 30]\n```\n:::\n:::\n\n\n::: {#cc940c2b .cell execution_count=9}\n``` {.python .cell-code}\n# 리스트 생성2\ny = [3.14, 'Park', [1, 2, 3], x]\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3.14, 'Park', [1, 2, 3], [10, 20, 30]]\n```\n:::\n:::\n\n\n::: {#17bc0c2e .cell execution_count=10}\n``` {.python .cell-code}\n# 리스트 인덱싱1 : 첫 번째 값 가져오기\nx = [15, 25, 35, 45]\nx[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n15\n```\n:::\n:::\n\n\n::: {#20119c56 .cell execution_count=11}\n``` {.python .cell-code}\n# 리스트 인덱싱2 : 마지막 값 가져오기\nx[-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n45\n```\n:::\n:::\n\n\n::: {#eca45a08 .cell execution_count=12}\n``` {.python .cell-code}\n# 리스트 슬라이싱1 : (stop index)는 포함하지 않음\nx = [10, 20, 30, [40, 50]]\nx[0:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n[10, 20]\n```\n:::\n:::\n\n\n::: {#70634adb .cell execution_count=13}\n``` {.python .cell-code}\n# 리스트 슬라이싱2\nx[1:]\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n[20, 30, [40, 50]]\n```\n:::\n:::\n\n\n::: {#c4e82e48 .cell execution_count=14}\n``` {.python .cell-code}\n# 리스트 슬라이싱3\nx[:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n[10, 20]\n```\n:::\n:::\n\n\n::: {#5e7e9336 .cell execution_count=15}\n``` {.python .cell-code}\n# 리스트 슬라이싱4 : 이중 리스트 슬라이싱\nprint(x[3])\nprint(x[3][0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[40, 50]\n40\n```\n:::\n:::\n\n\n::: {#5176e746 .cell execution_count=16}\n``` {.python .cell-code}\n# 리스트 변경\nx = [10, 20, 30]\nprint(x)\n\nx[0] = 50\nprint(x)\n\nx[1:3] = [90, 100]\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10, 20, 30]\n[50, 20, 30]\n[50, 90, 100]\n```\n:::\n:::\n\n\n<br>\n\n### 2.4.3. 튜플\n+ 튜플(tuple)\n  + 여러 개의 값을 저장할 수 있는 자료구조로, `()` 안에 값을 `,`로 구분하여 나열함\n  + 대부분 리스트와 비슷하지만, 한 번 저장한 값은 수정할 수 없음\n\n<br>\n\n::: {#9938b499 .cell execution_count=17}\n``` {.python .cell-code}\n# 튜플 생성1 : 빈 튜플 생성\nx = ()                                                            # x = tuple()\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n()\n```\n:::\n:::\n\n\n::: {#799feaae .cell execution_count=18}\n``` {.python .cell-code}\n# 튜플 생성2\nx = (1, 2, 3)\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1, 2, 3)\n```\n:::\n:::\n\n\n::: {#ca82d464 .cell execution_count=19}\n``` {.python .cell-code}\n# 튜플 생성3 : ()를 생략할 수 있음\nx = 1, 2, 3\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1, 2, 3)\n```\n:::\n:::\n\n\n::: {#3241ffd4 .cell execution_count=20}\n``` {.python .cell-code}\n# 튜플 생성4 : 0에서 9까지 정수 생성\nx = tuple(range(10))\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n```\n:::\n:::\n\n\n::: {#044cbb22 .cell execution_count=21}\n``` {.python .cell-code}\n# 튜플 생성5 : 리스트를 튜플로 자료형 변환\nx = ['월', '화', '수', '목', '금', '토', '일']\nx = tuple(x)\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n('월', '화', '수', '목', '금', '토', '일')\n```\n:::\n:::\n\n\n::: {#36bfee4e .cell execution_count=22}\n``` {.python .cell-code}\n# 튜플 변경 : Error!\n#x = (10, 20, 30)\n#x[0] = 100\n```\n:::\n\n\n::: {#c651ddac .cell execution_count=23}\n``` {.python .cell-code}\n# 튜플 인덱싱\nx = (10, 20, 30, 40)\nx[-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n40\n```\n:::\n:::\n\n\n::: {#0203ea89 .cell execution_count=24}\n``` {.python .cell-code}\n# 튜플 슬라이싱\nx[:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n(10, 20)\n```\n:::\n:::\n\n\n<br>\n\n### 2.4.4. 딕셔너리\n+ 딕셔너리(dictionary)\n  + 연관된 값을 키-값(key-value) 쌍으로 저장하는 자료구조로, `{}` 안에 `key: value` 값을 `,`로 구분하여 나열함\n  + 리스트나 튜플과 달리, 인덱스가 아닌 키(key)를 통해 값(value)에 접근함\n\n<br>\n\n::: {#4206afee .cell execution_count=25}\n``` {.python .cell-code}\n# 딕셔너리 생성1 : 빈 딕셔너리 생성\nx = {}                                                            # x = dict()\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{}\n```\n:::\n:::\n\n\n::: {#308ce234 .cell execution_count=26}\n``` {.python .cell-code}\n# 딕셔너리 생성2\nmenu = {'김밥': 3000, '라면': 5000}\nprint(menu)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'김밥': 3000, '라면': 5000}\n```\n:::\n:::\n\n\n::: {#c285ebfc .cell execution_count=27}\n``` {.python .cell-code}\n# 딕셔너리 요소 접근1\nmenu['김밥']\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n3000\n```\n:::\n:::\n\n\n::: {#4074470d .cell execution_count=28}\n``` {.python .cell-code}\n# 딕셔너리 요소 접근2\nmenu['어묵'] = 1500\nprint(menu)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'김밥': 3000, '라면': 5000, '어묵': 1500}\n```\n:::\n:::\n\n\n::: {#ea54fd24 .cell execution_count=29}\n``` {.python .cell-code}\n# 딕셔너리 요소 접근3 : Error!\n#menu['순대']\n```\n:::\n\n\n<br>\n\n### 2.4.5. 세트\n+ 세트(set)\n  + 집합에 관련된 것을 쉽게 처리하게 만든 자료구조로, `{}` 안에 값을 `,`로 구분하여 나열함\n  + 중복을 허용하지 않으며, 순서가 없어 인덱스로 각 요소에 접근할 수 없음\n\n<br>\n\n::: {#a0583437 .cell execution_count=30}\n``` {.python .cell-code}\n# 세트 생성1\nx = {10, 20, 30, 10}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{10, 20, 30}\n```\n:::\n:::\n\n\n::: {#e5f035ee .cell execution_count=31}\n``` {.python .cell-code}\n# 세트 생성2\nx = set([10, 20, 30])\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{10, 20, 30}\n```\n:::\n:::\n\n\n<br>\n\n## 2.5. 리스트 컴프리헨션\n+ 리스트 컴프리헨션(list comprehension)\n  + 원하는 자료들을 조회 또는 추출하여 리스트로 변환하는 표현식\n  + 조건식을 이용하여 같은 연산을 전체 항목이나 일부 항목에 적용할 수 있음\n\n<br>\n\n> **\\[표현식 for 변수 in 항목들 if 조건\\]**\n\n<br>\n\n+ 리스트 컴프리헨션 처리 과정\n  1. 항목들을 순차적으로 하나씩 꺼내옴\n  2. 조건식을 적용하여 해당 조건에 맞는 항목은 추출하고, 조건에 맞지 않으면 무시함\n  3. 위에서 추출한 항목을 리스트에 추가함\n\n\n<br>\n\n::: {#58bc1f52 .cell execution_count=32}\n``` {.python .cell-code}\n# 리스트 컴프리헨션1 : 조건이 없는 경우\nnum = [-20, -10, 0, 0, 10, 20]\n[x + 5 for x in num]\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n[-15, -5, 5, 5, 15, 25]\n```\n:::\n:::\n\n\n::: {#7948f692 .cell execution_count=33}\n``` {.python .cell-code}\n# 리스트 컴프리헨션2 : 조건이 있는 경우\n[1/x for x in num if x>0]\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n[0.1, 0.05]\n```\n:::\n:::\n\n\n<br>\n\n## 2.6. 선택문\n+ 선택문\n  + if 문을 이용하여 조건식이 True일 때만 코드를 실행하는 선택 구조\n\n![](./images/fig1-1.jpg){width=80%}\n![](./images/fig1-2.jpg){width=80%}\n![](./images/fig1-3.jpg){width=80%}\n![](./images/fig1-4.jpg){width=80%}\n\n::: {#335cb1a5 .cell execution_count=34}\n``` {.python .cell-code}\n# 무작위로 1~100 사이의 두 정수를 생성한 후, 큰 수부터 작은 수 순으로 출력\nimport random\na = random.randint(1, 100)\nb = random.randint(1, 100)\n\nif a<b:\n    a, b = b, a\n\nprint(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n46 8\n```\n:::\n:::\n\n\n<br>\n\n## 2.7. 반복문\n+ 반복문\n  + 일정한 횟수나 조건식을 만족하는 동안 코드를 반복 실행하는 제어 구조\n  + for 문 : 주어진 범위만큼 코드를 반복 실행\n  + while 문 : 조건식이 True인 동안 코드를 반복하다가, False가 되면 종료\n\n![](./images/fig1-5.jpg){width=80%}\n![](./images/fig1-6.jpg){width=80%}\n![](./images/fig1-7.jpg){width=80%}\n\n::: {#6be37f86 .cell execution_count=35}\n``` {.python .cell-code}\n# for 문 : 문자열을 3번 반복해서 출력\nfor i in range(3):\n    print(\"Hello!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello!\nHello!\nHello!\n```\n:::\n:::\n\n\n::: {#18d3cc12 .cell execution_count=36}\n``` {.python .cell-code}\n# for 문 : 반복범위의 값을 출력\nfor i in range(5):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n3\n4\n```\n:::\n:::\n\n\n::: {#7bf6eaae .cell execution_count=37}\n``` {.python .cell-code}\n# while 문 : 1~100 정수의 합 계산\nsum = 0\nnum = 1\n\nwhile num <= 100:\n    sum += num\n    num += 1\n\nprint(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5050\n```\n:::\n:::\n\n\n<br>\n\n## 2.8. 함수\n+ 함수(function)\n  + 특정한 기능을 수행하도록 미리 만들어 놓고, 필요할 때마다 호출하여 사용하는 일련의 코드\n  + Python에서 제공하는 내장 함수와 사용자가 직접 정의하는 사용자 정의 함수가 있음\n\n<br>\n\n+ 함수를 사용하는 이유\n  1. 중복된 코드를 함수로 분리하면 코드의 양이 줄어들고 가독성이 향상됨\n  2. 코드가 간결해져 전체 기능을 더 쉽게 이해할 수 있음\n  3. 프로그램의 흐름을 파악하기 쉬워져 유지·보수가 편리함\n  4. 필요한 기능만 함수로 정의해두면, 다른 프로그램에서 쉽게 재사용할 수 있어 효율적임\n\n<br>\n\n::: {#a4aabd2c .cell execution_count=38}\n``` {.python .cell-code}\n# enumerate() 함수 : for 문과 함께 사용하여 인덱스와 해당 값을 출력\nfor x, name in enumerate(['수박', '참외', '자두']):\n    print(x, name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 수박\n1 참외\n2 자두\n```\n:::\n:::\n\n\n::: {#d878b724 .cell execution_count=39}\n``` {.python .cell-code}\n# zip() 함수 : 두 리스트의 원소에 차례로 접근하여 짝을 지어 딕셔너리로 반환\nnum = [1, 2, 3]\nchar = ['A', 'B', 'C']\ndict(zip(num, char))\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n{1: 'A', 2: 'B', 3: 'C'}\n```\n:::\n:::\n\n\n::: {#f5eccdc3 .cell execution_count=40}\n``` {.python .cell-code}\n# random() 함수 : 0.0과 1.0 사이의 임의의 실수 반환(0.0은 포함하나, 1.0은 포함하지 않음)\nimport random\nfor i in range(10):\n    x = random.random()\n    print(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.7579293545196619\n0.864159095801573\n0.7079225397698945\n0.02945876910899048\n0.9082904238703692\n0.3293766090018486\n0.7329907555506004\n0.6135684012521786\n0.5896513410053912\n0.5769096473012636\n```\n:::\n:::\n\n\n<br>\n\n+ 사용자 정의 함수\n  + 인수(argument) : 호출된 함수에 전달할 값\n  + 매개변수(parameter) : 호출된 함수에서 전달받은 값을 임시로 할당하는 변수\n  + 반환값(return value) : 매개변수로부터 처리된 작업의 결과로, 호출한 함수로 값이 반환됨\n\n<br>\n\n> **def 함수명(매개변수1, 매개변수2, …):** <br>\n>　　**문장** <br>\n>　　**return 반환값**\n\n<br>\n\n+ 함수명 작성 규칙\n  + 변수명 작성 규칙과 동일함\n  + 일반적으로 소문자로 입력\n  + 작업을 나타내기 위해 동사와 명사를 함께 사용하는 경우가 많음 - (예) find_number\n  + 외부에 공개하는 함수일 경우 줄임말을 사용하지 않고 짧고 명료한 이름으로 정함\n\n<br>\n\n::: {#3c7f875d .cell execution_count=41}\n``` {.python .cell-code}\n# 사용자 정의 함수 : 두 개의 수를 입력받아 큰 수를 반환하는 함수\ndef max(num1, num2):\n    if num1 > num2:\n        return num1\n    else:\n        return num2\n\n#x = int(input('첫 번째 정수 입력 : '))\n#y = int(input('두 번째 정수 입력 : '))\n#print('큰 수 : ' max(x, y))\n```\n:::\n\n\n<br>\n\n+ 람다 함수(lambda function)\n  + 이름 없이 일시적으로 정의하여 사용할 수 있는 익명 함수\n  + 간단한 함수를 짧게 작성할 수 있어, 다른 함수의 인수로 자주 사용됨\n\n<br>\n\n> **lambda 매개변수들: 식**\n\n<br>\n\n::: {#109f80a2 .cell execution_count=42}\n``` {.python .cell-code}\n# 사용자 정의 함수\ndef plus_five(x):\n    return x+5\n\nplus_five(20)\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\n25\n```\n:::\n:::\n\n\n::: {#aa95d04c .cell execution_count=43}\n``` {.python .cell-code}\n# 람다 함수\n(lambda x: x+5)(20)\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\n25\n```\n:::\n:::\n\n\n::: {#2edf1ed2 .cell execution_count=44}\n``` {.python .cell-code}\n# 람다 표현식을 인수로 사용\n# map() 함수 : iterable 객체의 모든 요소에 특정 함수를 적용한 결과를 반환\nresult = map(lambda x: x+5, [15, 25, 35])\nprint(list(result))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[20, 30, 40]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "1_2_basic_files"
    ],
    "filters": [],
    "includes": {}
  }
}