{
  "hash": "0fe3e981ba3738ea6a0a20c778f54187",
  "result": {
    "engine": "jupyter",
    "markdown": "---\njupyter: python3\n---\n\n\n\n\n<h1>3. NumPy</h1>\n\n## 3.1. 넘파이 배열\n+ NumPy 라이브러리\n  + Numerical Python의 약자로, 과학적 연산과 수치 계산을 위한 Python 라이브러리\n  + 대규모 다차원 배열 및 행렬 연산에 최적화되어 있으며, 빠르고 효율적인 데이터 처리를 지원함\n \n<br>\n\n+ 넘파이 배열(ndarray)\n  + 동일한 자료형의 요소들로 구성된 다차원 배열\n  + 일반적인 리스트보다 메모리 효율이 뛰어나고, 연산 속도도 훨씬 빠름\n  + 순서가 있는(ordered) 구조로, 인덱싱과 슬라이싱을 통해 요소 접근 및 수정이 가능함\n\n<br>\n\n::: {#dd250d53 .cell execution_count=1}\n``` {.python .cell-code}\n# NumPy 라이브러리 설치\n#!pip install numpy\n```\n:::\n\n\n::: {#b648542e .cell execution_count=2}\n``` {.python .cell-code}\n# NumPy 라이브러리 불러오기\nimport numpy as np\n```\n:::\n\n\n::: {#bc8fa23c .cell execution_count=3}\n``` {.python .cell-code}\n# 넘파이 배열 생성1 : 리스트 사용\narr = np.array([1, 2, 3, 4])\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4]\n```\n:::\n:::\n\n\n::: {#4d29e715 .cell execution_count=4}\n``` {.python .cell-code}\n# 넘파이 배열 생성2\n# 하나의 배열에는 동일한 자료형만 저장할 수 있음\n# 만약 숫자와 문자를 동시에 배열에 넣으면 모두 문자열로 취급됨\narr = np.array([1, 2, \"A\"])\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['1' '2' 'A']\n```\n:::\n:::\n\n\n::: {#a8f9d573 .cell execution_count=5}\n``` {.python .cell-code}\n# 넘파이 배열 생성3 : 2차원 배열\n# 리스트를 중첩해서 인수로 넘겨 2차원 배열을 만듬\narr = np.array([[1, 2, 3, 4, 5],\n                [6, 7, 8, 9, 10]])\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 1  2  3  4  5]\n [ 6  7  8  9 10]]\n```\n:::\n:::\n\n\n::: {#8e1e4af1 .cell execution_count=6}\n``` {.python .cell-code}\n# 넘파이 배열 속성1 : 배열의 차원\narr.ndim\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n2\n```\n:::\n:::\n\n\n::: {#9ce65042 .cell execution_count=7}\n``` {.python .cell-code}\n# 넘파이 배열 속성2 : 배열 요소의 자료형\narr.dtype\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\ndtype('int32')\n```\n:::\n:::\n\n\n::: {#1a97943f .cell execution_count=8}\n``` {.python .cell-code}\n# 넘파이 배열 속성3 : 배열 요소의 byte 수\narr.itemsize\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n4\n```\n:::\n:::\n\n\n::: {#8c0007c1 .cell execution_count=9}\n``` {.python .cell-code}\n# 넘파이 배열 속성4 : 배열 요소의 개수\narr.size\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n10\n```\n:::\n:::\n\n\n::: {#6a741bb0 .cell execution_count=10}\n``` {.python .cell-code}\n# 넘파이 배열 속성5 : 배열 전체의 byte 수\narr.nbytes\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n40\n```\n:::\n:::\n\n\n::: {#c60a62bf .cell execution_count=11}\n``` {.python .cell-code}\n# 넘파이 배열 속성6 : 배열의 모양(행, 열)\narr.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n(2, 5)\n```\n:::\n:::\n\n\n::: {#50725e75 .cell execution_count=12}\n``` {.python .cell-code}\n# 넘파이 배열 속성7 : 전치(transpose)\narr.T\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\narray([[ 1,  6],\n       [ 2,  7],\n       [ 3,  8],\n       [ 4,  9],\n       [ 5, 10]])\n```\n:::\n:::\n\n\n<br>\n\n+ NumPy 라이브러리의 `arange()` 함수를 이용하여 등차수열을 생성할 수 있음\n  + start : 시작 값\n  + stop : 끝 값 (포함하지 않음)\n  + step : 차이 값; 간격(stride)\n\n<br>\n\n> numpy.arange(start, stop, step)\n\n<br>\n\n::: {#eb75f0d0 .cell execution_count=13}\n``` {.python .cell-code}\n# 등차수열 생성1 : 0부터 n-1까지 정수\narr = np.arange(5)\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2 3 4]\n```\n:::\n:::\n\n\n::: {#a3e616f8 .cell execution_count=14}\n``` {.python .cell-code}\n# 등차수열 생성2 : 시작 값, 끝 값 지정\narr = np.arange(2, 10)\nprint(arr)  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2 3 4 5 6 7 8 9]\n```\n:::\n:::\n\n\n::: {#9a45bb19 .cell execution_count=15}\n``` {.python .cell-code}\n# 등차수열 생성3 : 간격 지정\narr = np.arange(1, 10, 2)\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 3 5 7 9]\n```\n:::\n:::\n\n\n::: {#18024842 .cell execution_count=16}\n``` {.python .cell-code}\n# 등차수열 생성4 : 실수(float) 간격 지정\narr = np.arange(0, 1, 0.2)\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.  0.2 0.4 0.6 0.8]\n```\n:::\n:::\n\n\n<br>\n\n## 3.2. 넘파이 배열 인덱싱\n+ 넘파이 배열은 정수, 배열, 논리값(boolean) 등으로 인덱싱할 수 있음\n+ 리스트 인덱싱과 마찬가지로 `[]`를 사용하며, 인덱스는 0부터 시작\n+ 마스킹(masking), 논리값 인덱싱(boolean indexing)\n  + 특정 조건에 맞는 데이터를 추출하는 것\n  + 일반적으로 비교 연산자를 사용한 조건식을 사용함\n  + 특히 데이터가 많을 때 반복문 없이 조건 검사가 가능하여 효율적임\n\n<br>\n\n::: {#2484f9b8 .cell execution_count=17}\n``` {.python .cell-code}\n# 정수 인덱싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[1])\nprint(arr[-2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n20\n40\n```\n:::\n:::\n\n\n::: {#6d3b6db6 .cell execution_count=18}\n``` {.python .cell-code}\n# 배열 인덱싱\nidx = np.array([0, 2])\nprint(arr[idx])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10 30]\n```\n:::\n:::\n\n\n::: {#a8ea9498 .cell execution_count=19}\n``` {.python .cell-code}\n# 논리값(boolean) 인덱싱 : 조건을 만족하는 값 추출\nmask = np.array([True, False, True, True, False])\nprint(arr[mask])\nprint(arr[arr > 25])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10 30 40]\n[30 40 50]\n```\n:::\n:::\n\n\n<br>\n\n## 3.3. 넘파이 배열 슬라이싱\n+ 넘파이 배열에서 연속된 일부 요소를 잘라 추출하는 것\n+ `[start:stop:step]`를 사용하여 범위를 지정함\n  + start : 시작 인덱스\n  + stop : 끝 인덱스 (포함하지 않음)\n  + step : 증감 폭\n\n<br>\n\n::: {#944e1749 .cell execution_count=20}\n``` {.python .cell-code}\n# 배열 슬라이싱1 : 1번 인덱스부터 4번 인덱스 전까지\narr = np.array([11, 12, 13, 14, 15])\nprint(arr[1:4])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[12 13 14]\n```\n:::\n:::\n\n\n::: {#8908e706 .cell execution_count=21}\n``` {.python .cell-code}\n# 배열 슬라이싱2 : 처음부터 3번 인덱스 전까지\nprint(arr[:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[11 12 13]\n```\n:::\n:::\n\n\n::: {#513bf5d5 .cell execution_count=22}\n``` {.python .cell-code}\n# 배열 슬라이싱3 : 2번 인덱스부터 끝까지\nprint(arr[2:])            # [30 40 50] ()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[13 14 15]\n```\n:::\n:::\n\n\n::: {#f4a773e6 .cell execution_count=23}\n``` {.python .cell-code}\n# 배열 슬라이싱4 : 요소를 2개씩 건너뛰기\nprint(arr[::2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[11 13 15]\n```\n:::\n:::\n\n\n::: {#ac5cec93 .cell execution_count=24}\n``` {.python .cell-code}\n# 배열 슬라이싱5 : 역순 정렬\nprint(arr[::-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[15 14 13 12 11]\n```\n:::\n:::\n\n\n<br>\n\n## 3.4. 브로드캐스팅\n+ 브로드캐스팅(broadcasting)\n  + 서로 다른 형태의 배열 간 연산을 할 때 발생함\n  + 작은 차원의 배열을 큰 차원의 배열에 맞게 자동으로 변환한 후, 요소별로 연산을 수행함\n\n![](./images/fig2-1.png){width=70%}\n\n<br>\n\n::: {#36c8af03 .cell execution_count=25}\n``` {.python .cell-code}\n# 넘파이 배열 연산 : 동일한 위치의 요소 간 연산 숭행\narr1 = np.array([1, 2, 3])\narr2 = np.array([10, 20, 30])\narr1 + arr2\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\narray([11, 22, 33])\n```\n:::\n:::\n\n\n::: {#ad77e6e2 .cell execution_count=26}\n``` {.python .cell-code}\n# 넘파이 배열 연산 : 브로드캐스팅\narr = np.array([1, 2, 3, 4])\nprint(arr + 2)\nprint(arr * 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3 4 5 6]\n[2 4 6 8]\n```\n:::\n:::\n\n\n<br>\n\n## 3.5. 배열 정렬\n+ `np.sort(배열)` : 배열을 오름차순 정렬한 새로운 배열을 반환, 원본은 변하지 않음\n+ `배열.sort()` : 배열을 오름차순 정렬하고, 원본 자체를 변경함\n+ `np.argsort(배열)` : 정렬 시 각 요소가 위치하게 될 인덱스의 배열을 반환\n\n<br>\n\n::: {#a4e0ccc3 .cell execution_count=27}\n``` {.python .cell-code}\n# 배열 정렬1\narr = np.array([3, 2, 5, 1, 4])\nprint(np.sort(arr))\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5]\n[3 2 5 1 4]\n```\n:::\n:::\n\n\n::: {#a14ad8d2 .cell execution_count=28}\n``` {.python .cell-code}\n# 배열 정렬2\narr.sort()\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5]\n```\n:::\n:::\n\n\n::: {#5e15d77d .cell execution_count=29}\n``` {.python .cell-code}\n# 배열 정렬3\narr = np.array([3, 2, 5, 1, 4])\nprint(np.argsort(arr))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3 1 0 4 2]\n```\n:::\n:::\n\n\n<br>\n\n## 3.6. 얕은 복사와 깊은 복사\n+ 얕은 복사\n  + `=` 연산자 또는 `view()` 메소드를 사용한 복사\n  + 데이터의 메모리 주소만 복사하여, 원본과 데이터를 공유함\n  + 원본이나 복사본 중 하나를 수정하면 서로 영향을 미침\n\n<br>\n\n+ 깊은 복사\n  + `copy()` 메소드를 사용한 복사\n  + 완전히 새로운 메모리 공간에 데이터 전체를 복사함\n  + 원본과 복사본이 독립적이며, 어느 쪽을 수정해도 서로 영향을 주지 않음\n\n<br>\n\n::: {#596f1d93 .cell execution_count=30}\n``` {.python .cell-code}\n# 얕은 복사\narr1 = np.arange(6)\ncopy1 = arr1\n\nprint(arr1)\nprint(copy1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2 3 4 5]\n[0 1 2 3 4 5]\n```\n:::\n:::\n\n\n::: {#a8d4989d .cell execution_count=31}\n``` {.python .cell-code}\n# 복사본을 수정하면 원본도 변함\ncopy1[0] = 10\nprint(arr1)\nprint(copy1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10  1  2  3  4  5]\n[10  1  2  3  4  5]\n```\n:::\n:::\n\n\n::: {#d986be16 .cell execution_count=32}\n``` {.python .cell-code}\n# 깊은 복사\narr2 = np.arange(6)\ncopy2 = arr2.copy()\n\nprint(arr2)\nprint(copy2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2 3 4 5]\n[0 1 2 3 4 5]\n```\n:::\n:::\n\n\n::: {#e27f4493 .cell execution_count=33}\n``` {.python .cell-code}\n# 복사본을 수정해도 원본이 변하지 않음\ncopy2[0] = 20\nprint(arr2)\nprint(copy2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2 3 4 5]\n[20  1  2  3  4  5]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "2_1_numpy_files"
    ],
    "filters": [],
    "includes": {}
  }
}