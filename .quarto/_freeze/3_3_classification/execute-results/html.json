{
  "hash": "2115b6c22c47755765b23240c56346e3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\njupyter: python3\n---\n\n\n\n\n<h1>9. 지도학습 : 분류</h1>\n\n## 9.1. K-최근접 이웃\n+ 분류(classification)\n  + 지도학습의 한 종류로, 정답(label)이 범주형 변수일 때 사용됨\n  + 각 데이터가 속하는 집단(category) 간 관계를 학습함\n  + 학습된 모델은 새로운 데이터가 속하는 집단을 예측할 수 있음\n\n<br>\n\n+ 혼동 행렬(confusion matrix)\n\n|구분|예측 <br>Positive|예측 <br>Negative|\n|:------:|:------:|:------:|\n|**실제 Positive**|True Positive(TP)|False Negative(FN)|\n|**실제 Negative**|False Positive(FP)|True Negative(TN)|\n\n<br>\n\n+ 분류모델 평가지표\n\n|지표|설명|\n|:---------------:|:------------------------------|\n|정확도 <br>(accuracy)|전체 중에서 실제와 동일하게 예측한 비율, $\\frac{TP + TN}{TP + TN + FP + FN}$|\n|정밀도 <br>(precision)|모델이 양성이라고 예측한 것 중에서 실제로 양성인 비율, $\\frac{TP}{TP + FP}$|\n|재현율 <br>(recall, sensitivity)|실제 양성 중에서 모델이 양성이라고 예측한 비율, $\\frac{TP}{TP + FN}$|\n|특이도 <br>(specificity)|실제 음성 중에서 모델이 음성이라고 예측한 비율, $\\frac{TN}{TN + FP}$|\n|F1-score|정밀도와 재현율의 조화 평균|\n\n<br>\n\n+ K-최근접 이웃(K-Nearest Neighbors; K-NN)\n  + 새로운 데이터가 입력되었을 때, 가장 가까운 k개의 이웃 데이터를 기준으로 분류하는 통계 기법\n    1. 새로운 데이터와 가장 거리가 가까운 k개의 데이터를 찾음\n    2. 해당 k개의 데이터가 가장 많이 속한 클래스(class)로 새로운 데이터를 분류함(다수결 원리)\n  + 일반적으로 k는 동점 상황을 피하기 위해 홀수로 설정함\n  + 거리 계산에는 주로 유클리디안 거리(Euclidean distance)를 사용함\n\n<br>\n\n+ 예 : 천혜향과 레드향의 선호도 예측\n  + k=3일 때, 새로운 사람의 선호하는 맛(별 모양)과 가장 가까운 거리에 있는 3개의 데이터를 찾음\n  + 이웃 중 레드향을 좋아하는 사람이 2명, 천혜향을 좋아하는 사람이 1명이므로, 새로운 사람은 레드향을 선호하는 것으로 분류함\n\n<br>\n \n![](./images/fig3-9.jpg){width=70%}\n\n<br>\n\n+ k 값\n  + K-NN 알고리즘은 탐색할 이웃의 개수(k)에 따라 분류 결과가 달라질 수 있음\n    + k가 너무 크면, 데이터의 세세한 패턴을 반영하지 못해 과소적합 발생\n    + k가 너무 작으면, 개별 데이터에 민감하게 반응하여 과대적합 발생\n  + 일반적으로 최적의 k 값은 교차검증을 통해 모형 성능이 가장 좋은 k 값으로 결정함\n\n<br>\n\n+ 교차검증(k-fold cross-validation)\n  + 데이터를 여러 조각(fold)으로 나누고, 각 조각을 번갈아가며 검증 데이터(test data)로 사용\n  + 각 반복에서 모델 평가지표(정확도, F1-score, 정밀도, 재현도 등)를 계산\n  + 보통 각 반복에서 산출한 모델 평가지표의 평균 값을 모델 성능의 추정값으로 사용\n\n<br>\n\n![](./images/fig3-10.png)\n\n<br>\n\n+ 최적의 k 값 선택(하이퍼파라미터 튜닝; hyperparameter tunning)\n  1. 여러 이웃 수 k 값에 대해 교차검증을 반복 수행하여 각 k 값별로 모델 성능의 추정값을 계산\n  2. 모델 성능이 가장 좋은 k 값을 최적의 값으로 선택\n\n<br>\n\n+ 표준화 작업\n  + K-NN 알고리즘은 거리를 기반으로 하기 때문에, 데이터의 단위나 크기 차이가 크면 특정 특성(feature)이 크게 영향을 미쳐 엉뚱한 결과가 나올 수 있음\n  + 따라서 모든 특성이 비슷한 스케일(scale)로 반영되도록 표준화 작업이 필수적임\n  + z-점수 표준화\n    + 평균이 0, 표준편차가 1이 되도록 변환하는 방법, $x' = \\frac{x-\\mu}{\\sigma}$\n  + 최대-최소 표준화\n    + 데이터의 0~1 범위로 변환하는 방법, $x' = \\frac{x-min(x)}{max(x)-min(x)}$\n\n<br>\n\n<br>\n\n## 9.2. (실습) 인기 영화 분류\n+ \\[데이터\\] 캐글에서 제공하는 영화 데이터\n  + 총 4,775개의 관측값과 27개의 변수로 구성됨\n  + \\[실습파일\\] [chap11_movie_genre_final.csv](./chap11_movie_genre_final.csv)\n\n<br>\n\n::: {#207eadb9 .cell execution_count=1}\n``` {.python .cell-code}\n## (1) 데이터 확인 및 전처리\n```\n:::\n\n\n::: {#e09b2c77 .cell execution_count=2}\n``` {.python .cell-code}\n# 라이브러리 불러오기\nimport numpy as np\nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport seaborn as sns\n```\n:::\n\n\n::: {#9396a605 .cell execution_count=3}\n``` {.python .cell-code}\n# 데이터 불러오기\ndf = pd.read_csv('./data/chap11_movie_genre_final.csv')\ndf.head(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>original_title</th>\n      <th>target</th>\n      <th>vote_average</th>\n      <th>Action</th>\n      <th>Adventure</th>\n      <th>Fantasy</th>\n      <th>ScienceFiction</th>\n      <th>Crime</th>\n      <th>Drama</th>\n      <th>...</th>\n      <th>Mystery</th>\n      <th>History</th>\n      <th>War</th>\n      <th>Music</th>\n      <th>Documentary</th>\n      <th>Foreign</th>\n      <th>TVMovie</th>\n      <th>director</th>\n      <th>cast</th>\n      <th>keywords</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>19995</td>\n      <td>Avatar</td>\n      <td>7</td>\n      <td>7.2</td>\n      <td>1</td>\n      <td>1</td>\n      <td>1</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>James Cameron</td>\n      <td>SamWorthington,SigourneyWeaver,StephenLang,Zoe...</td>\n      <td>['culture clash', 'future', 'space war', 'spac...</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>285</td>\n      <td>Pirates of the Caribbean: At World's End</td>\n      <td>7</td>\n      <td>6.9</td>\n      <td>1</td>\n      <td>1</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>Gore Verbinski</td>\n      <td>JohnnyDepp,KeiraKnightley,OrlandoBloom,Stellan...</td>\n      <td>['ocean', 'drug abuse', 'exotic island', 'east...</td>\n    </tr>\n  </tbody>\n</table>\n<p>2 rows × 27 columns</p>\n</div>\n```\n:::\n:::\n\n\n::: {#4222c432 .cell execution_count=4}\n``` {.python .cell-code}\n# 데이터 정보\ndf.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 4775 entries, 0 to 4774\nData columns (total 27 columns):\n #   Column          Non-Null Count  Dtype  \n---  ------          --------------  -----  \n 0   id              4775 non-null   int64  \n 1   original_title  4775 non-null   object \n 2   target          4775 non-null   int64  \n 3   vote_average    4775 non-null   float64\n 4   Action          4775 non-null   int64  \n 5   Adventure       4775 non-null   int64  \n 6   Fantasy         4775 non-null   int64  \n 7   ScienceFiction  4775 non-null   int64  \n 8   Crime           4775 non-null   int64  \n 9   Drama           4775 non-null   int64  \n 10  Thriller        4775 non-null   int64  \n 11  Animation       4775 non-null   int64  \n 12  Family          4775 non-null   int64  \n 13  Western         4775 non-null   int64  \n 14  Comedy          4775 non-null   int64  \n 15  Romance         4775 non-null   int64  \n 16  Horror          4775 non-null   int64  \n 17  Mystery         4775 non-null   int64  \n 18  History         4775 non-null   int64  \n 19  War             4775 non-null   int64  \n 20  Music           4775 non-null   int64  \n 21  Documentary     4775 non-null   int64  \n 22  Foreign         4775 non-null   int64  \n 23  TVMovie         4775 non-null   int64  \n 24  director        4745 non-null   object \n 25  cast            4732 non-null   object \n 26  keywords        4775 non-null   object \ndtypes: float64(1), int64(22), object(4)\nmemory usage: 1007.4+ KB\n```\n:::\n:::\n\n\n::: {#d77cea56 .cell execution_count=5}\n``` {.python .cell-code}\n# 데이터 전처리 : 결측값 확인\n# 영화 장르를 특성(feature)으로 사용할 예정이므로,\n# director, cast 변수에 존재하는 결측값은 별도로 처리하지 않음\ndf.isna().sum()\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nid                 0\noriginal_title     0\ntarget             0\nvote_average       0\nAction             0\nAdventure          0\nFantasy            0\nScienceFiction     0\nCrime              0\nDrama              0\nThriller           0\nAnimation          0\nFamily             0\nWestern            0\nComedy             0\nRomance            0\nHorror             0\nMystery            0\nHistory            0\nWar                0\nMusic              0\nDocumentary        0\nForeign            0\nTVMovie            0\ndirector          30\ncast              43\nkeywords           0\ndtype: int64\n```\n:::\n:::\n\n\n<br>\n\n::: {#4d523b30 .cell execution_count=6}\n``` {.python .cell-code}\n## (2) 데이터 탐색\n```\n:::\n\n\n::: {#fbe98759 .cell execution_count=7}\n``` {.python .cell-code}\n# target 변수에 따른 영화 수\nplt.figure(figsize=(5, 3))\nplt.title('Distribution of Target')\nsns.histplot(df['target'], bins=10, kde=True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](3_3_classification_files/figure-html/cell-8-output-1.png){width=453 height=302}\n:::\n:::\n\n\n::: {#63735b7a .cell execution_count=8}\n``` {.python .cell-code}\n# 영화 평균 평점 분포\nplt.figure(figsize=(5, 3))\nplt.title('Distribution of Average Movie Rating')\nsns.histplot(df['vote_average'], bins=20, kde=True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](3_3_classification_files/figure-html/cell-9-output-1.png){width=453 height=302}\n:::\n:::\n\n\n::: {#9861da7f .cell execution_count=9}\n``` {.python .cell-code}\n# 데이터 집계 : 장르별 영화 수 (오름차순 정렬)\ngenre_count = df.loc[:, 'Action':'TVMovie'].sum()\ngenre_count.sort_values(inplace=True)\ngenre_count\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nTVMovie              8\nForeign             33\nWestern             81\nDocumentary        110\nWar                143\nMusic              184\nHistory            191\nAnimation          232\nMystery            347\nFantasy            421\nFamily             512\nHorror             518\nScienceFiction     535\nCrime              691\nAdventure          786\nRomance            891\nAction            1140\nThriller          1270\nComedy            1714\nDrama             2281\ndtype: int64\n```\n:::\n:::\n\n\n::: {#767cd744 .cell execution_count=10}\n``` {.python .cell-code}\n# 장르별 영화 수\n# 가장 많은 영화 장르는 드라마이고, 다음으로는 코미디, 스릴러, 액션 등의 순임\nplt.figure(figsize=(5, 5))\nplt.barh(genre_count.index, genre_count, color=sns.color_palette('hls',20))\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](3_3_classification_files/figure-html/cell-11-output-1.png){width=496 height=411}\n:::\n:::\n\n\n::: {#bd70e4a4 .cell execution_count=11}\n``` {.python .cell-code}\n# 상위 4개 장르에서 평균 평점 6.5 이상인 영화 수\n# 드라마 장르의 53.0%가 평균 평점이 6.5 이상으로 나타나므로,\n# 드라마 장르는 많이 제작되고 대중적 인기도 높다는 것을 알 수 있음\ntop_genres = ['Drama', 'Comedy', 'Thriller', 'Action']\nmin_avg_rating = 6.5\nfor genre in top_genres:\n    mask = (df[genre] == 1) & (df['vote_average']>=min_avg_rating)\n    total = genre_count[genre]\n    above_count = len(df[mask])\n    percent = above_count/total*100\n    print(f'{genre} : {total}편 중 평균 평점 {min_avg_rating} 이상 {above_count}편 ({percent:.1f}%)')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDrama : 2281편 중 평균 평점 6.5 이상 1208편 (53.0%)\nComedy : 1714편 중 평균 평점 6.5 이상 521편 (30.4%)\nThriller : 1270편 중 평균 평점 6.5 이상 415편 (32.7%)\nAction : 1140편 중 평균 평점 6.5 이상 355편 (31.1%)\n```\n:::\n:::\n\n\n<br>\n\n::: {#6cd3163c .cell execution_count=12}\n``` {.python .cell-code}\n## (3) K-NN을 이용한 분류\n```\n:::\n\n\n::: {#18d18cc2 .cell execution_count=13}\n``` {.python .cell-code}\n# 학습 데이터와 평가 데이터로 분할 (8:2 비율)\n# stratify=y 옵션 설정\n# → 분류 문제에서 각 클래스(calss)가 학습 데이터와 평가 데이터에 비슷한 비율로 포함되도록 함\n#   클래스 불균형 문제를 완화하고 모델 성능을 안정적으로 평가하기 위함\nX = df[['Action', 'Adventure', 'Fantasy', 'ScienceFiction', 'Crime', 'Drama', 'Thriller',\n        'Animation', 'Family', 'Western', 'Comedy', 'Romance', 'Horror', 'Mystery',\n        'History', 'War', 'Music', 'Documentary', 'Foreign', 'TVMovie']]\ny = df['target']\n\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)\n```\n:::\n\n\n::: {#df486b80 .cell execution_count=14}\n``` {.python .cell-code}\n# 최적의 k 값 선택\n# cv : 교차검증 폴드(fold) 수 (기본값 5)\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.model_selection import cross_val_score\n\nk_range = range(1, 21, 2)\nk_scores = []\n\nfor k in k_range:\n    knn = KNeighborsClassifier(n_neighbors=k)\n    scores = cross_val_score(knn, X_train, y_train, cv=2, scoring='accuracy')\n    k_scores.append(scores.mean())\n    print(f'k={k}일 때 정확도 : {scores.mean():.3f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nk=1일 때 정확도 : 0.291\nk=3일 때 정확도 : 0.330\nk=5일 때 정확도 : 0.373\nk=7일 때 정확도 : 0.382\nk=9일 때 정확도 : 0.388\nk=11일 때 정확도 : 0.393\nk=13일 때 정확도 : 0.402\nk=15일 때 정확도 : 0.417\nk=17일 때 정확도 : 0.424\nk=19일 때 정확도 : 0.432\n```\n:::\n:::\n\n\n::: {#775f005d .cell execution_count=15}\n``` {.python .cell-code}\n# 모델 성능이 가장 좋은 k 값 선택\nbest_k = k_range[k_scores.index(max(k_scores))]\nprint(f'최적의 k 값은 {best_k}이며, 평균 정확도는 {max(k_scores):.3f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n최적의 k 값은 19이며, 평균 정확도는 0.432\n```\n:::\n:::\n\n\n::: {#c85ebad3 .cell execution_count=16}\n``` {.python .cell-code}\n# K-NN 분류모델 생성 및 학습\nknn = KNeighborsClassifier(n_neighbors=best_k)\nknn.fit(X_train, y_train)\n\n# 분류모델 평가 : 정확도\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score\ny_pred = knn.predict(X_test)\naccuracy = accuracy_score(y_test, y_pred)\nprecision = precision_score(y_test, y_pred, average='weighted', zero_division=0)\nrecall = recall_score(y_test, y_pred, average='weighted', zero_division=0)\n\nprint(f'정확도 : {accuracy:.3f}')\nprint(f'정밀도 : {precision:.3f}')\nprint(f'재현율 : {recall:.3f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n정확도 : 0.443\n정밀도 : 0.385\n재현율 : 0.443\n```\n:::\n:::\n\n\n::: {#111e0a34 .cell execution_count=17}\n``` {.python .cell-code}\n# Action, Thriller 장르일 때, target 예측\nnewdata = pd.DataFrame([[1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0]], columns=X_train.columns)\ny_pred = knn.predict(newdata)\nprint(f'Action, Thriller 장르일 때, target 예측값 : {y_pred[0]:.0f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAction, Thriller 장르일 때, target 예측값 : 7\n```\n:::\n:::\n\n\n<br>\n\n##### **결과 및 시사점**\n+ 정확도는 43.8%로, 전체 영화 중 약 절반 이하만 정답 클래스를 올바르게 분류함\n+ 정밀도는 37.8%로, 재현율은 43.8%로, 전체 클래스에 대한 평균적인 분류 성능이 낮은 편임\n+ 세 지표가 모두 낮게 나타났으며, 이는 입력 데이터로 사용한 장르 정보만으로는 target을 효과적으로 구분하기 어려운 것으로 판단됨\n+ 또한 클래스 불균형이 존재하여, 일부 클래스는 모델이 거의 예측하지 못했을 가능성도 있음\n+ 따라서 모델 성능 개선을 위해 감독, 배우, 개봉 연도 등의 추가적인 특성을 포함할 필요가 있음\n\n<br>\n\n## 9.3. (실습) 농구선수 분류\n+ \\[데이터\\] 농구선수 데이터\n  + 총 1,340개의 관측값과 6개의 변수로 구성됨\n  + Target 변수는 선수의 경력이 5년 이상이면 1, 5년 미만이면 0을 나타냄\n  + \\[실습파일\\] [chap11_basketball_final.csv](./chap11_basketball_final.csv)\n\n<br>\n\n> **선수의 기량을 보고 5년 이상 경력을 가졌는지 예측할 수 있을까?**\n \n<br>\n\n::: {#f0e64a5d .cell execution_count=18}\n``` {.python .cell-code}\n## (1) 데이터 확인 및 전처리\n```\n:::\n\n\n::: {#4fe266bd .cell execution_count=19}\n``` {.python .cell-code}\n# 데이터 불러오기\ndf = pd.read_csv('./data/chap11_basketball_final.csv')\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Rebounds</th>\n      <th>Assists</th>\n      <th>Steals</th>\n      <th>Blocks</th>\n      <th>Turnovers</th>\n      <th>Target</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>4.1</td>\n      <td>1.9</td>\n      <td>0.4</td>\n      <td>0.4</td>\n      <td>1.3</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2.4</td>\n      <td>3.7</td>\n      <td>1.1</td>\n      <td>0.5</td>\n      <td>1.6</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2.2</td>\n      <td>1.0</td>\n      <td>0.5</td>\n      <td>0.3</td>\n      <td>1.0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1.9</td>\n      <td>0.8</td>\n      <td>0.6</td>\n      <td>0.1</td>\n      <td>1.0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2.5</td>\n      <td>0.3</td>\n      <td>0.3</td>\n      <td>0.4</td>\n      <td>0.8</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#1f9c9b40 .cell execution_count=20}\n``` {.python .cell-code}\n# 데이터 정보\ndf.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1340 entries, 0 to 1339\nData columns (total 6 columns):\n #   Column     Non-Null Count  Dtype  \n---  ------     --------------  -----  \n 0   Rebounds   1340 non-null   float64\n 1   Assists    1340 non-null   float64\n 2   Steals     1340 non-null   float64\n 3   Blocks     1340 non-null   float64\n 4   Turnovers  1340 non-null   float64\n 5   Target     1340 non-null   int64  \ndtypes: float64(5), int64(1)\nmemory usage: 62.9 KB\n```\n:::\n:::\n\n\n::: {#01f14707 .cell execution_count=21}\n``` {.python .cell-code}\n# 데이터 전처리 : 결측값 확인\ndf.isna().sum()\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\nRebounds     0\nAssists      0\nSteals       0\nBlocks       0\nTurnovers    0\nTarget       0\ndtype: int64\n```\n:::\n:::\n\n\n<br>\n\n::: {#71f49487 .cell execution_count=22}\n``` {.python .cell-code}\n## (2) 데이터 탐색\n```\n:::\n\n\n::: {#4cc61924 .cell execution_count=23}\n``` {.python .cell-code}\n# 5년 이상 경력 여부에 따른 선수 분포\nplt.figure(figsize=(5, 3))\nplt.title('Distribution of Experience')\nsns.countplot(x=df['Target'])\nplt.xlabel('')\nplt.xticks([0, 1], ['under 5 years', '5 years or more'])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](3_3_classification_files/figure-html/cell-24-output-1.png){width=444 height=283}\n:::\n:::\n\n\n::: {#7154daa6 .cell execution_count=24}\n``` {.python .cell-code}\n# 5년 이상 경력 여부에 따른 평균 농구 기술\ndf_mean = df.groupby('Target').mean()\n```\n:::\n\n\n::: {#665cbfd4 .cell execution_count=25}\n``` {.python .cell-code}\n# 5년 이상 경력 여부에 따른 평균 농구 기술 비교\n# 경기 기여도가 높은 기술(리바운드, 어시스트, 스틸, 블록)은 경력이 5년 이상인 선수가 더 뛰어남\n# 하지만 턴오버 횟수도 경력이 5년 이상인 선수가 더 많은 것으로 나타남\nplt.figure(figsize=(8, 3))\nsns.heatmap(df_mean, annot=True, cmap='Oranges', square=True)\nplt.ylabel('Experience')\nplt.yticks([0.5, 1.5], ['under \\n5 years', '5 years\\n or more'], rotation=0)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](3_3_classification_files/figure-html/cell-26-output-1.png){width=651 height=252}\n:::\n:::\n\n\n<br>\n\n::: {#d36506f6 .cell execution_count=26}\n``` {.python .cell-code}\n## (3) K-NN을 이용한 분류\n```\n:::\n\n\n::: {#a0a1aec8 .cell execution_count=27}\n``` {.python .cell-code}\n# 학습 데이터와 평가 데이터로 분할 (8:2 비율)\nX = df[['Rebounds','Assists','Steals','Blocks','Turnovers']]\ny = df['Target']\n\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n```\n:::\n\n\n::: {#774fb553 .cell execution_count=28}\n``` {.python .cell-code}\n# 최적의 k 값 선택\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.model_selection import cross_val_score\n\nk_range = range(1, 21, 2)\nk_scores = []\n\nfor k in k_range:\n    knn = KNeighborsClassifier(n_neighbors=k)\n    scores = cross_val_score(knn, X_train, y_train, cv=2, scoring='accuracy')\n    k_scores.append(scores.mean())\n    print(f'k={k}일 때 정확도 : {scores.mean():.3f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nk=1일 때 정확도 : 0.576\nk=3일 때 정확도 : 0.621\nk=5일 때 정확도 : 0.617\nk=7일 때 정확도 : 0.622\nk=9일 때 정확도 : 0.635\nk=11일 때 정확도 : 0.634\nk=13일 때 정확도 : 0.652\nk=15일 때 정확도 : 0.646\nk=17일 때 정확도 : 0.644\nk=19일 때 정확도 : 0.645\n```\n:::\n:::\n\n\n::: {#9e5b7270 .cell execution_count=29}\n``` {.python .cell-code}\n# 모델 성능이 가장 좋은 k 값 선택\nbest_k = k_range[k_scores.index(max(k_scores))]\nprint(f'최적의 k 값은 {best_k}이며, 평균 정확도는 {max(k_scores):.3f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n최적의 k 값은 13이며, 평균 정확도는 0.652\n```\n:::\n:::\n\n\n::: {#bea706d9 .cell execution_count=30}\n``` {.python .cell-code}\n# K-NN 분류모델 생성 및 학습\nknn = KNeighborsClassifier(n_neighbors=best_k)\nknn.fit(X_train, y_train)\n\n# 분류모델 평가 : 정확도\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score\ny_pred = knn.predict(X_test)\naccuracy = accuracy_score(y_test, y_pred)\nprecision = precision_score(y_test, y_pred)\nrecall = recall_score(y_test, y_pred)\n\nprint(f'정확도 : {accuracy:.3f}')\nprint(f'정밀도 : {precision:.3f}')\nprint(f'재현율 : {recall:.3f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n정확도 : 0.664\n정밀도 : 0.703\n재현율 : 0.811\n```\n:::\n:::\n\n\n::: {#ebd0e4d9 .cell execution_count=31}\n``` {.python .cell-code}\n# Rebounds 3회, Assists 3회, Steals 2회, Blocks 2회, Turnovers 4회일 때,\n# 5년 이상 경력 여부 예측\nnewdata = pd.DataFrame([[3, 3, 2, 2, 4]], columns=X_train.columns)\ny_pred = knn.predict(newdata)\ny_pred = pd.Series(y_pred).map({0: 'under 5 years', 1: '5 years and over'})\nprint(f'Rebounds 3회, Assists 3회, Steals 2회, Blocks 2회, Turnovers 4회일 때, 예측값 : {y_pred[0]}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRebounds 3회, Assists 3회, Steals 2회, Blocks 2회, Turnovers 4회일 때, 예측값 : 5 years and over\n```\n:::\n:::\n\n\n<br>\n\n##### **결과 및 시사점**\n+ 정확도는 66.4%로, 3명의 중 2명은 경력을 올바르게 분류함\n+ 정밀도는 70.3%로, 모델이 경력 5년 이상이라고 예측한 선수 중 약 70%가 실제로 경력이 많았음\n+ 재현율은 81.1%로, 실제로 경력 5년 이상인 선수 대부분을 모델이 정확히 분류함\n+ 모델 성능은 전반적으로 양호하며, 특히 높은 재현율을 통해 경력이 많은 선수를 잘 포착함\n+ 다만 정확도와 정밀도는 개선 여지가 있으며, 이를 위해 득점, 평균 출전 시간, 포지션 등의 추가적인 특성을 고려해볼 수 있음\n\n",
    "supporting": [
      "3_3_classification_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}